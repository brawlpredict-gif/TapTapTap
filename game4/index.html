<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
<title>Flappy Vasya</title>

<style>
html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    touch-action: none;
    user-select: none;
    -webkit-user-select: none;
}

canvas { display: block; }
</style>
</head>
<body>

<canvas id="game"></canvas>

<audio id="music" src="music.mp3" loop></audio>
<audio id="jumpSound" src="jump.mp3"></audio>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const music = document.getElementById("music");
const jumpSound = document.getElementById("jumpSound");

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);
document.addEventListener("contextmenu", e => e.preventDefault());

// ===== Картинки =====
const birdImg = new Image();
const bgImgs = [
    new Image(),
    new Image(),
    new Image()
];
birdImg.src = "bird.png";
bgImgs[0].src = "background1.jpg";
bgImgs[1].src = "background2.jpg";
bgImgs[2].src = "background3.jpg";

let imagesReady = false;
let loadedCount = 0;
[birdImg, ...bgImgs].forEach(img => {
    img.onload = () => {
        loadedCount++;
        if (loadedCount === 4) imagesReady = true;
    };
});

// ===== Игровые переменные =====
let gravity = 1400;
let velocity = 0;
let birdY = 0;
let birdX = 120;
let birdSize = 60;

let pipes = [];
let pipeWidth = 55;
let pipeGap = 240;
let pipeSpeed = 250;

let clouds = [];
for (let i = 0; i < 5; i++) {
    clouds.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height*0.5,
        size: 80 + Math.random()*80,
        speed: 20 + Math.random()*30
    });
}

let score = 0;
let gameOver = false;
let started = false;
let lastTime = 0;

let currentBgIndex = 0;

// ===== Функции игры =====
function initGame() { birdY = canvas.height/2; }

function createPipe() {
    let topHeight = Math.random() * (canvas.height - pipeGap - 200) + 100;
    pipes.push({ x: canvas.width, top: topHeight, passed: false });
}
setInterval(() => { if(!gameOver && started) createPipe(); }, 2500);

function startMusic() { music.pause(); music.currentTime=0; music.play().catch(()=>{}); }
function stopMusic() { music.pause(); music.currentTime=0; }

function resetGame() {
    birdY = canvas.height / 2;
    velocity = 0;
    pipes = [];
    score = 0;
    gameOver = false;
    started = true;
    currentBgIndex = 0;
    startMusic();
}

function jump() {
    if (!imagesReady) return;
    if (!started) { started=true; startMusic(); }
    if (gameOver) { resetGame(); return; }
    velocity = -520;
    jumpSound.currentTime=0; jumpSound.play().catch(()=>{});
}

let touchUsed = false;

document.addEventListener("touchstart", e => {
    touchUsed = true;
    jump();
});

document.addEventListener("mousedown", e => {
    if (!touchUsed) jump();
});

// Сбрасываем touchUsed после короткой паузы, чтобы мышь снова работала
document.addEventListener("touchend", e => {
    setTimeout(() => { touchUsed = false; }, 100);
});

function update(timestamp) {
    let deltaTime = (timestamp - lastTime)/1000;
    lastTime = timestamp;

    ctx.clearRect(0,0,canvas.width,canvas.height);

    if (!imagesReady) {
        ctx.fillStyle="#4ec0ca";
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle="white";
        ctx.font="40px Arial";
        ctx.textAlign="center";
        ctx.fillText("Загрузка...", canvas.width/2, canvas.height/2);
        requestAnimationFrame(update);
        return;
    }

    // ===== Смена фона каждые 30 очков =====
    currentBgIndex = Math.floor(score/15) % bgImgs.length;
    ctx.drawImage(bgImgs[currentBgIndex],0,0,canvas.width,canvas.height);

    // ===== Облака =====
    clouds.forEach(cloud => {
        cloud.x -= cloud.speed * deltaTime;
        ctx.globalAlpha = 0.6;
        ctx.fillStyle = "white";
        ctx.beginPath();
        ctx.ellipse(cloud.x, cloud.y, cloud.size, cloud.size*0.6, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;
        if (cloud.x + cloud.size < 0) cloud.x = canvas.width + cloud.size;
    });

    if (!started) {
        drawCenteredText("Тапни чтобы начать",50,"white");
        requestAnimationFrame(update);
        return;
    }

    if (gameOver) {
        drawCenteredText("GAME OVER",70,"red");
        drawCenteredText("Тапни для рестарта",30,"white",80);
        requestAnimationFrame(update);
        return;
    }

    // ===== Физика птицы =====
    velocity += gravity * deltaTime;
    birdY += velocity * deltaTime;

    if (birdY + birdSize > canvas.height || birdY < 0) { gameOver=true; stopMusic(); }

    // ===== Птичка =====
    ctx.save();
    ctx.translate(birdX + birdSize/2, birdY + birdSize/2);
    ctx.rotate(velocity*0.0015);
    ctx.drawImage(birdImg,-birdSize/2,-birdSize/2,birdSize,birdSize);
    ctx.restore();

    // ===== Трубы =====
    pipes.forEach(pipe => {
        pipe.x -= pipeSpeed*deltaTime;
        ctx.fillStyle="#2ecc71";
        ctx.fillRect(pipe.x,0,pipeWidth,pipe.top);
        ctx.fillRect(pipe.x,pipe.top+pipeGap,pipeWidth,canvas.height);
        if (birdX+birdSize>pipe.x && birdX<pipe.x+pipeWidth && (birdY<pipe.top || birdY+birdSize>pipe.top+pipeGap)) {
            gameOver=true; stopMusic();
        }
        if (!pipe.passed && pipe.x+pipeWidth<birdX) { pipe.passed=true; score++; }
    });
    pipes = pipes.filter(pipe=>pipe.x+pipeWidth>0);

    // ===== Счёт =====
    ctx.fillStyle="white";
    ctx.font="bold 60px Arial";
    ctx.textAlign="center";
    ctx.fillText(score,canvas.width/2,100);

    requestAnimationFrame(update);
}

function drawCenteredText(text,size,color,offset=0){
    ctx.fillStyle=color;
    ctx.font=size+"px Arial";
    ctx.textAlign="center";
    ctx.fillText(text,canvas.width/2,canvas.height/2+offset);
}

initGame();
requestAnimationFrame(update);
</script>

</body>

</html>


